## 9.22

限制某个tag的数量上限, 达到上限后就不能再分配该tag

在第一轮分配结束后, 就会出现分配不均, 即某个tag[i]在一轮分配后达到上限

在此后的分配过程中, 直接跳过tag[i], 则很难继续再分配其他tag出去

## 9.23
我发现平衡因子的主要影响因素在于 种子节点的数量和选取

目前的种子seed_check策略是, 检查当前种子所有距离在3以内的点有无其他种子节点

修改策略, 加入度数的限制 即将度数过高的节点排除考虑

好处是能够判断的距离增大到10甚至20

种子选取的数量和判断距离越大, 平衡因子越好

但是同时复制比就会很差

degree_threshold = 6 搜索距离=40 种子数=p*5000
```shell
1 : 790932
2 : 790932
3 : 790932
4 : 790931
5 : 2141192
6 : 790931
7 : 790931
8 : 790931
VERTEX_CNT : 3997962
ALL_TAG_CNT : 7677712
```

degree_threshold = 6 搜索距离=50 种子数=p*500
```shell
1 : 1668709
2 : 866376
3 : 866376
4 : 987789
5 : 866376
6 : 866376
7 : 866376
8 : 866376
VERTEX_CNT : 3997962
ALL_TAG_CNT : 7854754
```

degree_threshold = 6 搜索距离=70 种子数=p*500
```shell
1 : 982283
2 : 982283
3 : 982283
4 : 982282
5 : 982282
6 : 982282
7 : 982282
8 : 982282
VERTEX_CNT : 3997962
ALL_TAG_CNT : 7858259
```

degree_threshold = 8 搜索距离=200 种子数=p*500
```shell
1 : 744787
2 : 744787
3 : 744787
4 : 744787
5 : 2215508
6 : 744786
7 : 744786
8 : 900288
VERTEX_CNT : 3997962
ALL_TAG_CNT : 7584516
```



## 9.27

发现种子限制搜索距离为100, 度数限制为10时, 仍有很多种子只能只能搜到周围共3个节点0





## 9.30

9.27的策略在p较大时效果反而不如之前, 所以**只保留了最基础的度数和距离限制**



## 10.4

使用priority_queue + unordered_set实现了tag合并

但是**效果与不进行p倍增&&合并相近**



尝试另一种tag合并策略: 根据交集进行合并

计算出每两两tag中包含节点的交集, 得到1-p/2 <---> p/2+1, p 交集数量的权重矩阵

再利用**KM算法**计算二分图最大匹配



具体是: p=16时, 将只会输出8个分区

效果具体是: 

p = 16时: rf 2.0 -> rf 1.8

p = 512时: rf 2.63107 -> rf 2.55137

但是负载均衡在p=512时仍会出现**50倍于较小块的极端情况**



## 10.6

开会：

1. 种子tag 每个给不同tag
2. 阈值分配的bug



## 10.11

修复了阈值分配的bug，但是发现当threshold为threshold = num_vertices / p * 2时，很难“收敛”（分配tag使得每条边都属于某个分区）

```shell
threshold = num_vertices / p * 2
1 499744
2 499744
3 499744
4 499744
5 499744
6 499744
7 499744
8 499744
9 499744
10 499744
11 499744
12 499744
13 499744
14 499744
15 499744
16 499744
```

每个块都达到上限

即当p=16，threshold = num_vertices / p * 2时，无法完成分配

```shell
threshold = num_vertices / p * 5
RF : 2.93858
1202144 16
1202170 1
1206505 7
1220070 12
1249360 4
1249360 15
1601714 5
1649354 10
2.64652
```

```shell
threshold = num_vertices / p * 3
RF : 2.83291
1251408 4
1258761 10
1273575 14
1283871 13
1289975 6
1295277 15
1295863 11
1314836 9
2.5672
```

当p=32，threshold = num_vertices / p * 3时，无法完成分配

虽然复制因子陡增，但是观察到若能完成分配，复制因子和负载均衡较稳定

p=16(/2 == 8)，threshold = num_vertices / p * 3  ==> rf=2.68

```shell
RF : 3.34454
742890 15
744251 20
744553 19
746352 5
746715 23
746718 2
746784 21
747009 27
748649 9
799868 12
808036 18
827531 6
827607 31
833646 4
838225 17
841129 29
3.12408
```

p=32(/2 == 16)，threshold = num_vertices / p * 4  ==> rf=3.12408



## 10.14

方案1: 初始所有点随机打上tag, 效果最差, 不值得继续实验

方案2: 